# Prime_Finder 使用说明 (Group55)

## 目录
1. [项目文件结构](#1-项目文件结构)
2. [仿真验证](#2-仿真验证)
3. [编译与下载](#3-编译与下载)
4. [DE10-Lite 板级测试](#4-de10-lite-板级测试)

---

## 1. 项目文件结构

```
Prime_Finder/
├── 核心模块
│   ├── And_2bit_Group55.vhd        -- 2位与门
│   ├── Full_adder_Group55.vhd      -- 全加器
│   ├── Multiplier_4bit_Group55.vhd -- 4位乘法器
│   ├── RipSub_4bit_Group55.vhd     -- 4位减法器
│   ├── LongDivision_4bit_Group55.vhd -- 4位除法器
│   ├── Prime_Finder_Group55.vhd    -- 质数判断核心
│   └── Prime_Finder_Top_Group55.vhd -- DE10-Lite顶层封装
│
├── 测试文件 (Testbench)
│   ├── And_2bit_tb_Group55.vhd
│   ├── Full_adder_tb_Group55.vhd
│   ├── Multiplier_4bit_tb_Group55.vhd
│   ├── RipSub_4bit_tb_Group55.vhd
│   ├── LongDivision_4bit_tb_Group55.vhd
│   └── Prime_Finder_tb_Group55.vhd
│
└── 项目文件
    ├── Prime_Finder.qpf
    └── Prime_Finder.qsf
```

---

## 2. 仿真验证

### 2.1 启动仿真

1. 打开 Quartus，加载项目 `Prime_Finder.qpf`
2. 菜单: `Tools` → `Run Simulation Tool` → `RTL Simulation`

### 2.2 推荐仿真时间设置

| Testbench | 测试用例数 | 推荐时间 |
|-----------|-----------|----------|
| And_2bit_tb_Group55 | 4 | 100 ns |
| Full_adder_tb_Group55 | 8 | 150 ns |
| Multiplier_4bit_tb_Group55 | 4 | 100 ns |
| RipSub_4bit_tb_Group55 | 4 | 100 ns |
| LongDivision_4bit_tb_Group55 | 4 | 800 ns |
| Prime_Finder_tb_Group55 | 5 | 1200 ns |

### 2.3 各模块验证要点

#### And_2bit 验证

| 时间 | A | B | Y (期望) |
|------|---|---|----------|
| 10ns | 0 | 0 | 0 |
| 20ns | 0 | 1 | 0 |
| 30ns | 1 | 0 | 0 |
| 40ns | 1 | 1 | 1 |

**正确波形:** Y 只在 A=1 且 B=1 时为 1

---

#### Full_adder 验证

| A | B | Cin | Sum (期望) | Cout (期望) |
|---|---|-----|------------|-------------|
| 0 | 0 | 0   | 0          | 0           |
| 0 | 0 | 1   | 1          | 0           |
| 0 | 1 | 0   | 1          | 0           |
| 0 | 1 | 1   | 0          | 1           |
| 1 | 0 | 0   | 1          | 0           |
| 1 | 0 | 1   | 0          | 1           |
| 1 | 1 | 0   | 0          | 1           |
| 1 | 1 | 1   | 1          | 1           |

**正确波形:** Sum 在奇数个1时为1，Cout 在至少两个1时为1

---

#### Multiplier_4bit 验证

**推荐仿真时间: 100 ns**

| 测试 | A | B | Product (期望) | 说明 |
|------|---|---|----------------|------|
| 1 | 0 | 0 | 0 | 边界情况 |
| 2 | 3 | 5 | 15 | 小数乘法 |
| 3 | 7 | 8 | 56 | 中等数值 |
| 4 | 15 | 15 | 225 | 最大值 |

**正确波形:** Product = A × B

---

#### RipSub_4bit 验证

**推荐仿真时间: 100 ns**

| 测试 | A | B | Diff (期望) | Bout (期望) | 说明 |
|------|---|---|-------------|-------------|------|
| 1 | 10 | 7 | 3 | 0 | 正常减法 |
| 2 | 3 | 5 | 14 | 1 | 有借位/下溢 |
| 3 | 15 | 15 | 0 | 0 | 相等 |
| 4 | 0 | 1 | 15 | 1 | 边界下溢 |

**正确波形:** 
- A >= B 时: Diff = A - B, Bout = 0
- A < B 时: Diff = 16 + A - B (下溢), Bout = 1

**关于借位 (Bout) 的理解:**

Bout = 1 **不是"负数"**，而是表示"有借位"，即 A < B。

在4位无符号减法中，当 A < B 时会发生下溢：
- 例如 3 - 5：实际计算 3 - 5 = -2，但4位无符号数无法表示负数
- 结果变成 16 + (-2) = 14，同时 Bout = 1 表示发生了借位

**如何得到真正的差值：**
- Bout = 0 时：结果就是 Diff
- Bout = 1 时：真正的差值 = Diff - 16（负数）

**在本项目中的用途：** `LongDivision_4bit` 用 Bout 判断"够不够减"：
- Bout = 0 → 被除数 >= 除数，继续减
- Bout = 1 → 被除数 < 除数，停止除法

---

#### LongDivision_4bit 验证

**波形信号说明:**

| 信号名 | 类型 | 说明 |
|--------|------|------|
| `Dividend_tb` | 输入 | 被除数 (要被除的数) |
| `Divisor_tb` | 输入 | 除数 |
| `CLK_tb` | 输入 | 时钟信号，每个上升沿执行一次减法 |
| `Load_tb` | 输入 | 加载信号：1=加载新数据，0=开始计算 |
| `Quotient_tb` | 输出 | 商 (除法结果) |
| `Remainder_tb` | 输出 | 余数 |

**波形观察要点:**

1. **Load_tb = 1 时**：加载 Dividend 和 Divisor，Quotient 清零
2. **Load_tb = 0 后**：每个时钟周期执行一次减法
3. **计算完成后**：Quotient 和 Remainder 稳定不变

**推荐仿真时间: 800 ns**

**测试用例:**

| 测试 | Dividend | Divisor | Quotient (期望) | Remainder (期望) | 说明 |
|------|----------|---------|-----------------|------------------|------|
| 1 | 15 | 3 | 5 | 0 | 整除 |
| 2 | 7 | 2 | 3 | 1 | 有余数 |
| 3 | 5 | 7 | 0 | 5 | 被除数<除数 |
| 4 | 8 | 0 | 15 | 8 | 除以零 |

**波形示例 (15 ÷ 3 = 5 余 0):**

```
CLK_tb:       ___/‾‾‾\___/‾‾‾\___/‾‾‾\___/‾‾‾\___/‾‾‾\___/‾‾‾\___

Load_tb:      ‾‾‾‾‾‾‾\________________________________________________

Dividend_tb:  ----[15]------------------------------------------------

Divisor_tb:   ----[3]-------------------------------------------------

Quotient_tb:  ----[0]---[1]---[2]---[3]---[4]---[5]---[5]---[5]-------
                  加载   减1次  减2次  减3次  减4次  减5次  完成!

Remainder_tb: ----[15]--[12]--[9]---[6]---[3]---[0]---[0]---[0]-------
```

**计算过程图解 (二进制):**

```
输入:  Dividend = 1111 (15)
       Divisor  = 0011 (3)

初始:  reg_dividend = 1111,  reg_quotient = 0000

第1次: 1111 - 0011 = 1100    reg_dividend = 1100,  reg_quotient = 0001
       (15)   (3)    (12)                   (12)                  (1)

第2次: 1100 - 0011 = 1001    reg_dividend = 1001,  reg_quotient = 0010
       (12)   (3)    (9)                    (9)                   (2)

第3次: 1001 - 0011 = 0110    reg_dividend = 0110,  reg_quotient = 0011
       (9)    (3)    (6)                    (6)                   (3)

第4次: 0110 - 0011 = 0011    reg_dividend = 0011,  reg_quotient = 0100
       (6)    (3)    (3)                    (3)                   (4)

第5次: 0011 - 0011 = 0000    reg_dividend = 0000,  reg_quotient = 0101
       (3)    (3)    (0)                    (0)                   (5)

第6次: 0000 - 0011 = 1101    sub_borrow = 1 (借位!) → done = 1 → 停止!
       (0)    (3)    (13)

最终:  Quotient  = 0101 (5)
       Remainder = 0000 (0)

验证:  15 = 3 × 5 + 0  ✓
```

**正确波形验证:** 
- Load=1 时：Quotient 清零，Remainder 等于 Dividend
- Load=0 后：每个时钟 Quotient+1，Remainder 减少
- 计算完成：Quotient × Divisor + Remainder = Dividend

---

#### Prime_Finder 验证

**波形信号说明:**

| 信号名 | 类型 | 说明 |
|--------|------|------|
| `Dividend_tb` | 输入 | 要检测的数 (被除数) |
| `Divisor_tb` | 输入 | 测试用的除数 |
| `CLK_tb` | 输入 | 时钟信号 |
| `Load_tb` | 输入 | 加载信号：1=加载新数据，0=开始计算 |
| `Q_out_tb` | 输出 | 商 |
| `R_out_tb` | 输出 | 余数 |
| `Is_Prime_tb` | 输出 | 质数标志：1=可能是质数，0=不是质数 |

**质数判断逻辑:**

```
Is_Prime = 0 (不是质数) 的条件:
  1. Dividend = 0 或 1 (特殊情况)
  2. R_out = 0 且 Q_out > 1 且 Divisor > 1 且 Divisor < Dividend
     (找到非平凡因子，能被整除)

Is_Prime = 1 (可能是质数) 的条件:
  - 不满足上述条件
```

**推荐仿真时间: 1200 ns**

**测试用例:**

| 测试 | Dividend | Divisor | Q_out | R_out | Is_Prime | 说明 |
|------|----------|---------|-------|-------|----------|------|
| 1 | 1 | 2 | 0 | 1 | 0 | 特殊情况 (1不是质数) |
| 2 | 6 | 2 | 3 | 0 | 0 | 非质数 (找到因子) |
| 3 | 7 | 2 | 3 | 1 | 1 | 质数 (不能整除) |
| 4 | 9 | 3 | 3 | 0 | 0 | 非质数 (找到因子) |
| 5 | 13 | 2 | 6 | 1 | 1 | 质数 (不能整除) |

**波形示例 (测试6÷2，非质数):**

```
时间:      40ns      60ns      80ns     100ns     120ns     140ns
            │         │         │         │         │         │
CLK_tb:    _/‾\_     _/‾\_     _/‾\_     _/‾\_     _/‾\_     _/‾\_

Load_tb:   ‾‾‾‾‾‾‾‾‾‾‾\________________________________________________

Dividend:  ──[0110]───────────────────────────────────────────────────
              (6)

Divisor:   ──[0010]───────────────────────────────────────────────────
              (2)

Q_out:     ──[0000]───[0001]───[0010]───[0011]───[0011]───[0011]──────
              (0)       (1)       (2)       (3)      完成!

R_out:     ──[0110]───[0100]───[0010]───[0000]───[0000]───[0000]──────
              (6)       (4)       (2)       (0)      余数=0!

Is_Prime:  ──[1]──────[1]──────[1]──────[0]──────[0]──────[0]─────────
                                          ↑
                                    R=0且Q>1，找到因子!
```

**计算过程图解 (二进制) - 6÷2:**

```
输入:  Dividend = 0110 (6)
       Divisor  = 0010 (2)

初始:  reg_dividend = 0110,  reg_quotient = 0000

第1次: 0110 - 0010 = 0100    reg_dividend = 0100,  reg_quotient = 0001
       (6)    (2)    (4)                    (4)                   (1)

第2次: 0100 - 0010 = 0010    reg_dividend = 0010,  reg_quotient = 0010
       (4)    (2)    (2)                    (2)                   (2)

第3次: 0010 - 0010 = 0000    reg_dividend = 0000,  reg_quotient = 0011
       (2)    (2)    (0)                    (0)                   (3)

第4次: 0000 - 0010 = 1110    sub_borrow = 1 (借位!) → done = 1 → 停止!
       (0)    (2)    (14)

最终:  Q_out = 0011 (3),  R_out = 0000 (0)

质数判断:
  - R_out = 0000 (余数为0) ✓
  - Q_out = 0011 > 0001 (商大于1) ✓
  - Divisor = 0010 > 0001 (除数大于1) ✓
  - Divisor = 0010 < 0110 = Dividend (除数小于被除数) ✓
  → 满足所有条件，Is_Prime = 0 (6不是质数)

验证:  6 = 2 × 3 + 0  ✓
```

**波形示例 (测试7÷2，质数):**

```
输入:  Dividend = 0111 (7)
       Divisor  = 0010 (2)

初始:  reg_dividend = 0111,  reg_quotient = 0000

第1次: 0111 - 0010 = 0101    reg_dividend = 0101,  reg_quotient = 0001
       (7)    (2)    (5)                    (5)                   (1)

第2次: 0101 - 0010 = 0011    reg_dividend = 0011,  reg_quotient = 0010
       (5)    (2)    (3)                    (3)                   (2)

第3次: 0011 - 0010 = 0001    reg_dividend = 0001,  reg_quotient = 0011
       (3)    (2)    (1)                    (1)                   (3)

第4次: 0001 - 0010 = 1111    sub_borrow = 1 (借位!) → done = 1 → 停止!
       (1)    (2)    (15)

最终:  Q_out = 0011 (3),  R_out = 0001 (1)

质数判断:
  - R_out = 0001 ≠ 0000 (余数不为0) ✗
  → 条件不满足，Is_Prime = 1 (7可能是质数)

验证:  7 = 2 × 3 + 1  ✓
```

**正确波形验证:**
- 余数=0 且 商>1 且 除数>1 且 除数<被除数 → Is_Prime=0
- 否则 Is_Prime=1 (除非是0或1)

---

## 3. 编译与下载

### 3.1 编译项目

1. 打开 Quartus，加载 `Prime_Finder.qpf`
2. `Processing` → `Start Compilation` (或 `Ctrl+L`)
3. 等待编译完成

**成功标志:** 状态栏显示 "Full Compilation was successful"

### 3.2 下载到开发板

1. 连接 DE10-Lite (USB Blaster)
2. `Tools` → `Programmer`
3. 选择 USB-Blaster，点击 `Start`

---

## 4. DE10-Lite 板级测试

### 4.1 硬件连接

```
┌─────────────────────────────────────────────────────────┐
│                    DE10-Lite 开发板                      │
│                                                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │  HEX5  HEX4  HEX3  HEX2  HEX1  HEX0            │   │
│  │  [余数十位][余数个位] [熄灭] [熄灭] [商十位][商个位]  │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
│  LED9 = Is_Prime (质数指示灯)                           │
│                                                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │  SW9   SW8   SW7-SW4        SW3-SW0            │   │
│  │ [Load] [--] [被除数4位]    [除数4位]            │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 4.2 操作步骤

1. **设置被除数**: 拨动 SW7-SW4
   - 例如: 设置 7 = 0111 → SW7=0, SW6=1, SW5=1, SW4=1

2. **设置除数**: 拨动 SW3-SW0
   - 例如: 设置 2 = 0010 → SW3=0, SW2=0, SW1=1, SW0=0

3. **加载数据**: 
   - 将 SW9 拨到 ON (Load=1)
   - 再拨回 OFF (Load=0)

4. **观察结果**:
   - HEX0-HEX1: 显示商 (十进制)
   - HEX4-HEX5: 显示余数 (十进制)
   - LED9: 亮=可能是质数, 灭=不是质数

### 4.3 测试用例

#### 测试1: 验证除法功能

| 被除数 (SW7-4) | 除数 (SW3-0) | 期望商 | 期望余数 |
|----------------|--------------|--------|----------|
| 1111 (15) | 0011 (3) | 05 | 00 |
| 1101 (13) | 0100 (4) | 03 | 01 |
| 0111 (7) | 0010 (2) | 03 | 01 |
| 1010 (10) | 0011 (3) | 03 | 01 |

#### 测试2: 验证质数判断

**测试质数 (LED9 应该亮):**

| 数字 | 被除数 | 除数 | 商 | 余数 | LED9 |
|------|--------|------|----|----|------|
| 2 | 0010 | 0010 | 01 | 00 | 亮 (除数=被除数) |
| 3 | 0011 | 0010 | 01 | 01 | 亮 |
| 5 | 0101 | 0010 | 02 | 01 | 亮 |
| 7 | 0111 | 0010 | 03 | 01 | 亮 |
| 7 | 0111 | 0011 | 02 | 01 | 亮 |
| 11 | 1011 | 0010 | 05 | 01 | 亮 |
| 13 | 1101 | 0010 | 06 | 01 | 亮 |

**测试非质数 (LED9 应该灭):**

| 数字 | 被除数 | 除数 | 商 | 余数 | LED9 |
|------|--------|------|----|----|------|
| 0 | 0000 | 0010 | - | - | 灭 |
| 1 | 0001 | 0010 | - | - | 灭 |
| 4 | 0100 | 0010 | 02 | 00 | 灭 |
| 6 | 0110 | 0010 | 03 | 00 | 灭 |
| 6 | 0110 | 0011 | 02 | 00 | 灭 |
| 8 | 1000 | 0010 | 04 | 00 | 灭 |
| 9 | 1001 | 0011 | 03 | 00 | 灭 |
| 12 | 1100 | 0010 | 06 | 00 | 灭 |
| 15 | 1111 | 0011 | 05 | 00 | 灭 |

---

## 附录: 开关二进制对照表

| 十进制 | 二进制 (SW7-SW4 或 SW3-SW0) |
|--------|------------------------------|
| 0 | 0000 |
| 1 | 0001 |
| 2 | 0010 |
| 3 | 0011 |
| 4 | 0100 |
| 5 | 0101 |
| 6 | 0110 |
| 7 | 0111 |
| 8 | 1000 |
| 9 | 1001 |
| 10 | 1010 |
| 11 | 1011 |
| 12 | 1100 |
| 13 | 1101 |
| 14 | 1110 |
| 15 | 1111 |

---

*文档版本: 1.0*
*最后更新: 2024年*
*组号: Group55*
