# Phase 2 优化方案 - Prime_Finder 系统升级

> **目标**: 从4个维度提升质数检测系统的性能

---

## 优化方案总览

| 序号 | 优化方案 | 优化方向 | 核心思想 |
|:----:|----------|----------|----------|
| 1 | 并行除法器 | 提高速度 | 多个除法器同时工作 |
| 2 | 除法器内部优化 | 提高速度 | CLA减法器 |
| 3 | 6k±1算法 | 提高速度 | 数学优化，减少测试次数 |
| 4 | 16位扩展 | 扩展位数 | 时分复用输入 |

---

## 优化1: 并行除法器 (外部架构优化)

### 原理

**阶段1问题**: 只有1个除法器，必须串行测试每个除数。

**解决方案**: 实例化多个除法器，**同时**测试多个除数。

### 图解

```
阶段1 (串行):
                    N=13
                      │
                      ▼
                 ┌─────────┐
                 │ 除法器  │ ← 复用同一个
                 └─────────┘
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
    时钟1-5       时钟6-10      时钟11-15
     N÷2           N÷3           N÷5
        
    总时间: 15个时钟周期


阶段2 (并行):
                    N=13
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
   ┌─────────┐  ┌─────────┐  ┌─────────┐
   │ 除法器1 │  │ 除法器2 │  │ 除法器3 │ ← 3个独立硬件
   │  N÷2    │  │  N÷3    │  │  N÷5    │
   └─────────┘  └─────────┘  └─────────┘
        │             │             │
        ▼             ▼             ▼
      R=1           R=1           R=3
        │             │             │
        └─────────────┴─────────────┘
                      │
                      ▼
              全部R≠0 → 质数!
        
    总时间: 5个时钟周期 (快3倍!)
```

### 性能对比

| 测试的数N | 阶段1(串行) | 阶段2(3路并行) | 加速比 |
|-----------|-------------|----------------|--------|
| 7 | 10周期 | 5周期 | 2x |
| 11 | 15周期 | 5周期 | 3x |
| 13 | 15周期 | 5周期 | 3x |

### 为什么FPGA能并行?

- FPGA不是CPU，每个模块实例都是**独立的物理电路**
- 3个除法器 = 3套硬件，天然同时运行
- 这是FPGA相比CPU的核心优势

---

## 优化2: 除法器内部优化 (CLA + 流水线)

优化2包含两个子优化，分别针对**延迟**和**吞吐量**:

```
┌─────────────────────────────────────────────────────────────┐
│                  除法器内部优化                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────────────┐    ┌────────────────────┐           │
│  │ 2a: CLA快速减法器  │    │ 2b: 流水线架构     │           │
│  │                    │    │                    │           │
│  │ 优化: 单次减法延迟 │    │ 优化: 多次操作吞吐 │           │
│  │ 效果: Fmax ↑ 2倍   │    │ 效果: 吞吐量 ↑ K倍 │           │
│  └────────────────────┘    └────────────────────┘           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2a: CLA快速减法器

#### 原理

**阶段1问题**: 纹波减法器的借位像多米诺骨牌，必须逐位传递。

**解决方案**: 提前计算出所有借位，不用等待传递。

#### 图解

```
阶段1 (纹波借位):

    A[3] B[3]   A[2] B[2]   A[1] B[1]   A[0] B[0]
      │   │      │   │       │   │       │   │
      ▼   ▼      ▼   ▼       ▼   ▼       ▼   ▼
    ┌─────┐    ┌─────┐     ┌─────┐     ┌─────┐
    │SUB3 │◄───│SUB2 │◄────│SUB1 │◄────│SUB0 │◄── 0
    └──┬──┘    └──┬──┘     └──┬──┘     └──┬──┘
       │          │           │           │
    ═══╪══════════╪═══════════╪═══════════╪════► 借位传递方向
       │          │           │           │
       ▼          ▼           ▼           ▼
     D[3]       D[2]        D[1]        D[0]
    
    延迟: 4T (必须等每一级完成)


阶段2 (进位预测):

    A[3] B[3]   A[2] B[2]   A[1] B[1]   A[0] B[0]
      │   │      │   │       │   │       │   │
      └───┴──────┴───┴───────┴───┴───────┴───┴───┐
                                                  │
                      ┌───────────────────────────┘
                      │
                      ▼
              ┌──────────────┐
              │  预测逻辑    │  ← 同时计算所有借位!
              │  B0,B1,B2,B3 │
              └──────────────┘
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
      D[3]          D[2]          D[1]          D[0]
    
    延迟: 2T (快2倍!)
```

#### 数学原理 (简化版)

定义:
- **G[i]** = A[i] AND B'[i] (该位产生借位)
- **P[i]** = A[i] XOR B'[i] (该位传播借位)

借位公式:
```
B[1] = G[0]
B[2] = G[1] OR (P[1] AND G[0])
B[3] = G[2] OR (P[2] AND G[1]) OR (P[2] AND P[1] AND G[0])
```

**关键**: 所有B[i]只依赖输入，可以同时计算!

#### CLA性能对比

| 位宽 | 纹波延迟 | CLA延迟 | 加速比 |
|------|----------|---------|--------|
| 4位 | 4T | 2T | 2x |
| 8位 | 8T | 3T | 2.7x |
| 16位 | 16T | 4T | 4x |

---

### 2b: 流水线架构

#### 原理

**阶段1问题**: 除法器一次只能处理一个数，下一个数必须等待。

**解决方案**: 将除法拆成多级，不同数据同时在不同级处理。

#### 图解

```
阶段1 (非流水线):

    处理N=7:  [████████████] 完成
    处理N=8:               [████████████] 完成
    处理N=9:                            [████████████] 完成
    
    时间轴:   T1──T5──T10──T15──T20──T25──T30
    
    处理3个数需要: 15个周期


阶段2 (流水线):

              Stage1   Stage2   Stage3   Stage4   Stage5
    时钟1:    [N=7]
    时钟2:    [N=8]    [N=7]
    时钟3:    [N=9]    [N=8]    [N=7]
    时钟4:             [N=9]    [N=8]    [N=7]
    时钟5:                      [N=9]    [N=8]    [N=7]→完成
    时钟6:                               [N=9]    [N=8]→完成
    时钟7:                                        [N=9]→完成
    
    处理3个数需要: 7个周期 (快2倍+)
```

#### 流水线性能对比

| 处理数量 | 非流水线 | 流水线 | 加速比 |
|----------|----------|--------|--------|
| 1个数 | 5周期 | 5周期 | 1x |
| 3个数 | 15周期 | 7周期 | 2.1x |
| 10个数 | 50周期 | 14周期 | 3.6x |
| 100个数 | 500周期 | 104周期 | **4.8x** |

**结论**: 批量处理时，流水线优势巨大!

---

### 优化2总结

| 子优化 | 优化目标 | 效果 | 适用场景 |
|--------|----------|------|----------|
| CLA减法器 | 降低延迟 | Fmax ↑ 2x | 所有场景 |
| 流水线 | 提高吞吐 | 批量处理 ↑ 5x | 连续检测多个数 |

两者可以**组合使用**: 流水线每级内部使用CLA减法器，获得双重加速!

---

## 优化3: 6k±1 数学优化

### 原理

**数学定理**: 所有大于3的质数，都可以写成 **6k±1** 的形式。

**证明**:
```
任何整数都是以下6种形式之一:
  6k     → 能被6整除 (不是质数)
  6k+1   → 可能是质数 ✓
  6k+2   → 能被2整除 (不是质数)
  6k+3   → 能被3整除 (不是质数)
  6k+4   → 能被2整除 (不是质数)
  6k+5   → 等于6k-1，可能是质数 ✓

结论: 除了2和3，质数只可能是 6k-1 或 6k+1 形式
```

### 算法优化

```
传统方法 (测试N=97):
  测试除数: 2, 3, 4, 5, 6, 7, 8, 9, ... 96
  共需要测试: 95次

6k±1优化方法:
  Step 1: 测试能否被2整除 → 97%2=1 ✓
  Step 2: 测试能否被3整除 → 97%3=1 ✓
  Step 3: 只测试6k±1形式的除数，且只到√97≈9.8:
          测试5 (6×1-1) → 97%5=2 ✓
          测试7 (6×1+1) → 97%7=6 ✓
          下一个是11，但11>9.8，停止
  
  共需要测试: 4次!
```

### 测试次数对比

| 被测数N | 传统方法 | 6k±1优化 | 减少比例 |
|---------|----------|----------|----------|
| 13 | 11次 | 2次 | 82% |
| 97 | 95次 | 4次 | 96% |
| 251 | 249次 | 6次 | 98% |

### 除数生成序列

```
标准序列: 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17...
优化序列: 2, 3, 5, 7, 11, 13, 17, 19, 23, 25, 29, 31...
              └─┬─┘ └───┬───┘ └───┬───┘ └───┬───┘
             6×1±1    6×2±1    6×3±1    6×4±1
```

---

## 优化4: 16位扩展 (时分复用输入)

### 原理

**问题**: 开发板只有10个开关，如何输入16位数据?

**解决方案**: 分两次输入，用按键确认。

### 操作流程

```
┌─────────────────────────────────────────────────────────────┐
│                   16位时分复用输入                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Step 1: 输入高8位                                          │
│  ┌─────────────────────────────────┐                        │
│  │ SW[7:0] = 高8位数据             │                        │
│  │ 按 KEY[0] 锁存                  │                        │
│  └─────────────────────────────────┘                        │
│          │                                                   │
│          ▼                                                   │
│  ┌─────────────────┐                                        │
│  │ 高8位寄存器     │ ← 保存高位                             │
│  │ [15:8]          │                                        │
│  └─────────────────┘                                        │
│                                                              │
│  Step 2: 输入低8位                                          │
│  ┌─────────────────────────────────┐                        │
│  │ SW[7:0] = 低8位数据             │                        │
│  │ 按 KEY[1] 开始计算              │                        │
│  └─────────────────────────────────┘                        │
│          │                                                   │
│          ▼                                                   │
│  ┌─────────────────┐                                        │
│  │ 完整16位数据    │                                        │
│  │ [15:0]          │ → 送入质数检测器                       │
│  └─────────────────┘                                        │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 引脚分配

```
输入:
  SW[7:0]  = 8位数据 (高位/低位复用)
  SW[9]    = 模式选择 (可选)
  KEY[0]   = 锁存高8位
  KEY[1]   = 锁存低8位，开始计算

输出:
  HEX4-HEX0 = 16位数十进制显示 (最大65535，需要5位)
  LED[9]    = Is_Prime
  LED[7:0]  = 状态指示
```

### 扩展效果

| 版本 | 位数 | 范围 | 质数数量 |
|------|------|------|----------|
| 阶段1 | 4位 | 0-15 | 6个 |
| 8位版 | 8位 | 0-255 | 54个 |
| **16位版** | 16位 | 0-65535 | **6542个** |

---

## 视频演示脚本 (5分钟)

### 开场 (30秒)

**画面**: 展示4个优化的架构图

**旁白**:
> "阶段2我们从4个维度优化了质数检测系统:
> 第一，并行除法器，用硬件并行加速;
> 第二，除法器内部优化，包括CLA减法器和流水线;
> 第三，6k±1算法，用数学减少测试次数;
> 第四，16位扩展，用时分复用突破输入限制。"

---

### 优化1演示 - 并行除法器 (1分钟)

**画面1**: 架构对比图
```
展示串行 vs 并行的结构图
```

**旁白**:
> "阶段1只有1个除法器，测试N=13需要串行测试2,3,5,7四个除数。
> 阶段2我们实例化了4个独立的除法器，它们同时工作。"

**画面2**: ModelSim波形
```
同时显示4个除法器的输出信号
- R2, R3, R5, R7 四条波形
- 在同一时刻全部出结果
```

**旁白**:
> "从波形可以看到，4个除法器在同一时刻完成计算。
> 相比阶段1，速度提升了约3倍。"

---

### 优化2演示 - 除法器内部优化 (1分15秒)

#### 2a: CLA减法器 (45秒)

**画面1**: 原理对比图
```
纹波结构: 借位串行传递 (4级延迟)
CLA结构: 借位并行计算 (2级延迟)
```

**旁白**:
> "阶段1的减法器使用纹波结构，借位必须逐位传递，4位需要4级延迟。
> CLA减法器通过预测逻辑，同时计算出所有借位，只需要2级延迟。"

**画面2**: Quartus Timing Report截图
```
对比两个版本的Fmax
- RipSub_4bit: Fmax = XXX MHz
- CLA_Sub_4bit: Fmax = XXX MHz
```

**旁白**:
> "从Quartus的时序报告可以看到，最高频率提升了约2倍。"

#### 2b: 流水线架构 (30秒)

**画面**: 流水线时序图
```
展示多个数据同时在不同Stage处理
```

**旁白**:
> "流水线架构将除法分成多级，不同数据可以同时处理。
> 批量检测100个数时，吞吐量提升近5倍。
> CLA和流水线组合使用，可以获得双重加速。"

---

### 优化3演示 - 6k±1算法 (1分钟)

**画面1**: 数学原理图
```
展示6k, 6k+1, 6k+2, 6k+3, 6k+4, 6k+5的分类
标记哪些可能是质数
```

**旁白**:
> "根据数论，除了2和3，所有质数都是6k加1或6k减1的形式。
> 这意味着我们只需要测试这些形式的除数。"

**画面2**: 计数器对比
```
测试N=97:
- 传统方法计数器: 显示95
- 优化方法计数器: 显示4
```

**旁白**:
> "测试97是否为质数，传统方法需要95次除法，优化后只需要4次。
> 测试次数减少了96%。"

---

### 优化4演示 - 16位扩展 (1分钟)

**画面1**: 操作演示
```
Step 1: 开关设置高8位，按KEY0
Step 2: 开关设置低8位，按KEY1
显示器显示完整16位数
```

**旁白**:
> "开发板只有10个开关，我们用时分复用的方法输入16位数据。
> 先输入高8位并锁存，再输入低8位开始计算。"

**画面2**: 板级演示
```
输入N=65521 (16位范围内最大质数)
LED[9]亮起，表示是质数
```

**旁白**:
> "现在我们可以测试0到65535范围内的数，包含6542个质数。
> 相比阶段1的6个质数，范围扩大了1000倍以上。"

---

### 总结 (30秒)

**画面**: 性能对比总表

| 优化项 | 阶段1 | 阶段2 | 提升 |
|--------|-------|-------|------|
| 并行度 | 1路 | 4路 | 3x速度 |
| 减法延迟 | 4T | 2T | 2x频率 |
| 测试N=97次数 | 95 | 4 | 96%减少 |
| 测试范围 | 0-15 | 0-65535 | 1000x |

**旁白**:
> "总结一下，阶段2通过硬件并行、电路优化、算法改进、位数扩展四个维度，
> 全面提升了质数检测系统的性能。谢谢!"

---

## 实现优先级

| 优先级 | 方案 | 预计时间 | 依赖关系 |
|--------|------|----------|----------|
| P0 | 6k±1算法 | 2h | 无 |
| P1 | 并行除法器 | 3h | 无 |
| P2 | CLA减法器 | 3h | 无 |
| P3 | 16位扩展 | 4h | 需要先完成自动检测 |

---

## 文件结构

```
Phase2/
├── Prime_Finder_Parallel_Group55.vhd     -- 并行除法器版本
├── CLA_Sub_4bit_Group55.vhd              -- 快速减法器
├── Prime_Finder_6k1_Group55.vhd          -- 6k±1算法版本
├── Prime_Finder_16bit_Group55.vhd        -- 16位扩展版本
├── Prime_Finder_Top_Phase2_Group55.vhd   -- 阶段2顶层
└── testbench/
    ├── Parallel_tb.vhd
    ├── CLA_Sub_tb.vhd
    ├── Algorithm_6k1_tb.vhd
    └── Extend_16bit_tb.vhd
```

---

*策略: 每个优化都有清晰的原理解释和可量化的对比数据*
