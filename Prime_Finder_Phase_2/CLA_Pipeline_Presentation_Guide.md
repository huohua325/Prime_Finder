# Testbench 2: CLA与流水线验证 - 视频讲解指南

**文件**: `CLA_Pipeline_tb_Group55.vhd`  
**时长建议**: 8-12分钟  
**演讲者**: Group 55

---

## 📋 演讲大纲

| 部分 | 内容 | 时长 |
|------|------|------|
| 1 | 开场与目标介绍 | 1分钟 |
| 2 | RipSub vs CLA 原理对比 | 3分钟 |
| 3 | 流水线(Pipeline)设计原理 | 2分钟 |
| 4 | 代码走读与讲解 | 3分钟 |
| 5 | 波形演示与结果分析 | 2分钟 |
| 6 | 总结与性能收益 | 1分钟 |

---

## 第一部分：开场与目标介绍 (1分钟)

### 讲稿参考

> "大家好，我来讲解第二个Testbench——CLA与流水线验证。
> 
> 这个测试台的目的是验证我们对除法器内部的两项关键优化：
> 1. **CLA (Carry-Lookahead Adder)** - 超前进位加法器，提升单次减法速度
> 2. **Pipeline (流水线)** - 提升连续运算的吞吐量
> 
> 我们将通过与原版RipSub（行波借位）进行对比来展示优化效果。"

### 屏幕展示
- 打开 `CLA_Pipeline_tb_Group55.vhd`
- 指向文件头部的注释（第1-9行）

---

## 第二部分：RipSub vs CLA 原理对比 (3分钟)

### 2.1 什么是RipSub（行波借位减法器）

#### 核心问题：进位链的"多米诺骨牌"效应

```
传统行波减法器的进位传递：

位3 ← 位2 ← 位1 ← 位0
 ↑     ↑     ↑     ↑
等待   等待   等待   起点

C(1) = f(C(0))         -- 第1级需要等待C(0)
C(2) = f(C(1))         -- 第2级需要等待C(1)
C(3) = f(C(2))         -- 第3级需要等待C(2)
COUT = f(C(3))         -- 最终进位需要等待C(3)
```

#### RipSub代码（指向 `RipSub_4bit_Group55.vhd` 第52-56行）

```vhdl
-- 进位逐级传递，每一级都依赖前一级！
C(0) <= '1';
C(1) <= (A(0) and Bn(0)) or (A(0) and C(0)) or (Bn(0) and C(0));  -- 需要C(0)
C(2) <= (A(1) and Bn(1)) or (A(1) and C(1)) or (Bn(1) and C(1));  -- 需要C(1)
C(3) <= (A(2) and Bn(2)) or (A(2) and C(2)) or (Bn(2) and C(2));  -- 需要C(2)
COUT <= (A(3) and Bn(3)) or (A(3) and C(3)) or (Bn(3) and C(3));  -- 需要C(3)
```

**关键点**：4位数需要4级延迟（4个门级延迟）

---

### 2.2 CLA如何解决这个问题

#### 核心思想：进位预测（Carry Lookahead）

CLA引入两个关键概念：
- **G (Generate)** - 生成：该位能"产生"进位
- **P (Propagate)** - 传播：该位能"传递"进位

```
数学定义：
G(i) = A(i) AND B'(i)   -- 当A=1且B'=1时，肯定产生进位
P(i) = A(i) XOR B'(i)   -- 当A≠B'时，会传递上一级的进位
```

#### 进位预测公式

```
所有进位可以同时计算，不需要等待！

C(1) = G(0) + P(0)·C(0)

C(2) = G(1) + P(1)·G(0) + P(1)·P(0)·C(0)

C(3) = G(2) + P(2)·G(1) + P(2)·P(1)·G(0) + P(2)·P(1)·P(0)·C(0)

C(4) = G(3) + P(3)·G(2) + P(3)·P(2)·G(1) + P(3)·P(2)·P(1)·G(0) 
     + P(3)·P(2)·P(1)·P(0)·C(0)
```

#### CLA代码（指向 `LongDivision_CLA_Pipeline_Group55.vhd` 第77-97行）

```vhdl
-- Step 2: 计算Generate和Propagate (并行)
G <= cla_a and Bn;     -- 所有G同时计算
P <= cla_a xor Bn;     -- 所有P同时计算

-- Step 3: 进位预测 (关键优化: 所有进位同时计算!)
C(0) <= '1';
C(1) <= G(0) or (P(0) and C(0));
C(2) <= G(1) or (P(1) and G(0)) or (P(1) and P(0) and C(0));
C(3) <= G(2) or (P(2) and G(1)) or (P(2) and P(1) and G(0)) 
             or (P(2) and P(1) and P(0) and C(0));
C(4) <= G(3) or (P(3) and G(2)) or (P(3) and P(2) and G(1))
             or (P(3) and P(2) and P(1) and G(0))
             or (P(3) and P(2) and P(1) and P(0) and C(0));
```

---

### 2.3 速度对比图示

```
┌─────────────────────────────────────────────────────────────┐
│                    RipSub (行波减法器)                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│    时间 →   T1      T2      T3      T4                      │
│            ┌──┐    ┌──┐    ┌──┐    ┌──┐                     │
│   C(0)→    │位0│ →  │位1│ →  │位2│ →  │位3│                    │
│            └──┘    └──┘    └──┘    └──┘                     │
│                                     ↓                       │
│                                   结果                      │
│                                                             │
│   总延迟: 4级门延迟                                          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    CLA (超前进位加法器)                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│    时间 →   T1          T2                                  │
│            ┌────────────────┐                               │
│   输入→    │计算G、P (并行)  │                                │
│            └───────┬────────┘                               │
│                    ↓                                        │
│            ┌────────────────┐                               │
│            │C(1),C(2),C(3),C(4)│ ← 同时计算所有进位！           │
│            │    (并行)       │                               │
│            └───────┬────────┘                               │
│                    ↓                                        │
│                  结果                                       │
│                                                             │
│   总延迟: 2级门延迟                                          │
└─────────────────────────────────────────────────────────────┘

速度提升: 4级 → 2级 = 2倍！
```

---

## 第三部分：流水线(Pipeline)设计原理 (2分钟)

### 3.1 什么是流水线

#### 类比：洗衣房的例子

```
场景：3件衣服需要 洗(30min) → 烘(30min) → 叠(30min)

❌ 无流水线 (串行处理):
┌────────────────────────────────────────────────────┐
│ 衣服1: [洗][烘][叠]                                  │
│ 衣服2:           [洗][烘][叠]                        │
│ 衣服3:                     [洗][烘][叠]              │
│                                                    │
│ 总时间: 3 × 90min = 270分钟                         │
└────────────────────────────────────────────────────┘

✅ 流水线 (并行处理):
┌────────────────────────────────────────────────────┐
│ 时间:    T1    T2    T3    T4    T5                │
│ 洗:     [衣服1][衣服2][衣服3]                        │
│ 烘:           [衣服1][衣服2][衣服3]                  │
│ 叠:                 [衣服1][衣服2][衣服3]            │
│                                                    │
│ 总时间: 5 × 30min = 150分钟 (节省44%！)              │
└────────────────────────────────────────────────────┘
```

### 3.2 除法器中的流水线

我们的除法器流水线分为两个阶段：

```
Stage 1 (输入锁存)     Stage 2+ (迭代计算)
┌──────────────┐      ┌──────────────────┐
│ 锁存被除数    │  →   │ 使用CLA做减法    │
│ 锁存除数      │      │ 更新商和余数     │
│ 检查除零      │      │ 判断是否完成     │
└──────────────┘      └──────────────────┘
     1个周期               多个周期
```

#### 流水线代码（指向 `LongDivision_CLA_Pipeline_Group55.vhd` 第108-169行）

```vhdl
-- Stage 1: 输入锁存 (流水线入口)
if Load = '1' then
    s1_dividend <= Dividend;    -- 锁存输入
    s1_divisor <= Divisor;
    s1_valid <= '1';            -- 标记有效
end if;

-- Stage 1 -> Stage 2: 传递到计算阶段
if s1_valid = '1' and computing = '0' then
    reg_dividend <= s1_dividend;
    reg_divisor <= s1_divisor;
    reg_quotient <= "0000";
    computing <= '1';           -- 开始计算
    s1_valid <= '0';            -- 释放Stage 1
end if;

-- Stage 2+: 迭代减法 (使用CLA)
if computing = '1' and div_by_zero = '0' then
    if cla_borrow = '0' then
        reg_dividend <= cla_diff;       -- 够减：更新余数
        reg_quotient <= reg_quotient + 1;
    else
        done_internal <= '1';           -- 不够减：完成
        computing <= '0';
    end if;
end if;
```

### 3.3 流水线的关键优势

```
场景：连续计算 7÷3, 8÷3, 9÷3

无流水线:
┌────────────────────────────────────────────────────┐
│ 输入7→ [计算7÷3] → 输入8→ [计算8÷3] → 输入9→ [计算9÷3] │
│                                                    │
│ 必须等待前一个完成才能输入下一个                      │
└────────────────────────────────────────────────────┘

有流水线:
┌────────────────────────────────────────────────────┐
│ 时钟:   C1    C2    C3    C4    C5    ...          │
│ Load:   [7]   [8]   [9]                            │
│ Stage1: [锁7] [锁8] [锁9]                           │
│ Stage2:       [算7] [算7→] [算8] [算9] ...          │
│                                                    │
│ 输入可以连续进入，无需等待！                          │
└────────────────────────────────────────────────────┘
```

---

## 第四部分：代码走读与讲解 (3分钟)

### 4.1 Testbench结构概览

打开 `CLA_Pipeline_tb_Group55.vhd`，讲解整体结构：

```vhdl
-- 两个被测模块
UUT_CLA: LongDivision_CLA_Pipeline_Group55  -- CLA优化版
UUT_RIP: LongDivision_4bit_Group55          -- 原版RipSub

-- 共享相同输入
Dividend => Dividend,
Divisor => Divisor,
CLK => CLK,
Load => Load,

-- 分别有各自的输出
Quotient => Q_CLA/Q_Rip,
Done => Done_CLA/Done_Rip
```

### 4.2 Part 1: 单次速度对比

```vhdl
-- Part 1: 单次操作对比 CLA vs RipSub
Dividend <= "0111";  -- 7
Divisor <= "0011";   -- 3
Load <= '1';
wait for CLK_PERIOD;
Load <= '0';

-- 等待两者都完成
wait until Done_CLA = '1' and Done_Rip = '1';

-- 验证结果相同
assert Q_CLA = Q_Rip report "FAIL: Quotient mismatch!";
```

**观察要点**: 在波形中，`Done_CLA`应该比`Done_Rip`更早变为'1'

### 4.3 Part 2: 流水线吞吐量测试

```vhdl
-- Part 2: 连续输入展示流水线效果
-- 输入1: 7/3
Dividend <= "0111";
Load <= '1';
wait for CLK_PERIOD;

-- 输入2: 8/3 (不等待第一个完成！)
Dividend <= "1000";
wait for CLK_PERIOD;

-- 输入3: 9/3
Dividend <= "1001";
wait for CLK_PERIOD;

Load <= '0';
-- 3个输入在3个时钟周期内全部送入
```

**观察要点**: 3个`Done`信号依次触发，间隔小于单个完整计算时间

---

## 第五部分：波形演示与结果分析 (2分钟)

### 5.1 ModelSim波形观察点

运行仿真后，展示以下信号：

```
必看信号 (按顺序排列):
1. CLK              -- 时钟
2. Load             -- 加载信号
3. Dividend         -- 被除数输入
4. Done_CLA         -- CLA版本完成标志 ← 关键！
5. Done_Rip         -- RipSub版本完成标志 ← 关键！
6. Q_CLA            -- CLA版本商输出
7. Q_Rip            -- RipSub版本商输出
8. cycle_cla        -- CLA周期计数
9. cycle_rip        -- RipSub周期计数
```

### 5.2 预期波形结果

```
Part 1 单次对比 (7÷3):
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ Load    ┐_________________________________________________  │
│          ↓                                                  │
│ Done_CLA ________________┐‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾  │
│                          ↑ (更早完成！)                      │
│ Done_Rip ______________________┐‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾  │
│                                ↑ (稍晚完成)                  │
│                                                             │
│ Q_CLA    XXXX──────────[0010]───────────────────────────────│
│ Q_Rip    XXXX────────────────[0010]─────────────────────────│
│          (两者结果相同: 7÷3=2)                               │
└─────────────────────────────────────────────────────────────┘

Part 2 流水线效果 (7,8,9÷3):
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ Load    ┐─────┐_____________________________________________│
│         ↓     ↓                                             │
│ Dividend [7]  [8]  [9]  [稳定]                               │
│              ↓    ↓    ↓                                    │
│ Done_CLA ___________┐_┐_┐___  (3个Done依次触发)              │
│                     ↑ ↑ ↑                                   │
│                    间隔很短，流水线效果！                     │
└─────────────────────────────────────────────────────────────┘
```

### 5.3 控制台输出预期

```
# === Part 1: CLA vs RipSub Speed Comparison ===
# Test: 7 / 3
# Result: 7/3 = 2 R 1
# CLA cycles: 2, RipSub cycles: 3    ← CLA更少周期！

# === Part 2: Pipeline Throughput (3 consecutive inputs) ===
# Inputs sent: 7, 8, 9 (all /3)
# Watch waveform: Done signals should trigger in sequence
```

---

## 第六部分：总结与性能收益 (1分钟)

### 讲稿参考

> "最后，让我总结这个Testbench验证的两个关键优化：
> 
> **第一，CLA超前进位**：
> - RipSub的进位是串行传递的，4位需要4级延迟
> - CLA通过预测公式，并行计算所有进位，只需2级延迟
> - 速度提升约2倍
> 
> **第二，流水线设计**：
> - 将除法分成输入锁存和迭代计算两个阶段
> - 当前一个数据在Stage 2计算时，新数据可以进入Stage 1
> - 提升连续运算的吞吐量
> 
> 这两项优化是互补的：CLA加速单次减法，流水线加速连续处理。
> 
> 以上就是Testbench 2的全部内容，谢谢大家！"

---

## 📎 附录：关键代码位置速查

| 内容 | 文件 | 行号 |
|------|------|------|
| CLA的G/P计算 | `LongDivision_CLA_Pipeline_Group55.vhd` | 77-79 |
| CLA进位预测公式 | `LongDivision_CLA_Pipeline_Group55.vhd` | 82-97 |
| 流水线Stage 1 | `LongDivision_CLA_Pipeline_Group55.vhd` | 115-126 |
| 流水线Stage 2 | `LongDivision_CLA_Pipeline_Group55.vhd` | 131-153 |
| RipSub进位链 | `RipSub_4bit_Group55.vhd` | 52-56 |
| TB Part 1测试 | `CLA_Pipeline_tb_Group55.vhd` | 145-175 |
| TB Part 2测试 | `CLA_Pipeline_tb_Group55.vhd` | 177-201 |

---

## ✅ 录制前检查清单

- [ ] ModelSim已打开并编译所有文件
- [ ] 波形窗口已添加必要信号
- [ ] 运行一次完整仿真确认无错误
- [ ] 熟悉各部分的切换时机
- [ ] 准备好放大波形的关键区域

---

*文档生成时间: 2024年*  
*Group 55 - Prime Finder Project Phase 2*
