# Prime Finder - Phase 2 优化实现

> **Group 55** | FPGA 质数检测系统 | 阶段2 优化方案完整文档

---

## 目录

1. [项目简介](#一项目简介)
2. [优化方案总览](#二优化方案总览)
3. [文件清单](#三文件清单)
4. [各优化详细说明](#四各优化详细说明)
5. [Testbench 仿真指南](#五testbench-仿真指南)
6. [开发板验证](#六开发板验证)
7. [快速开始](#七快速开始)

---

## 一、项目简介

### 项目背景

本项目实现一个基于 FPGA 的质数检测系统，在阶段1实现基础功能后，阶段2从**4个维度**进行优化：

| 维度 | 优化方向 | 核心思想 |
|:----:|----------|----------|
| 架构 | 并行化 | 多个硬件单元同时工作 |
| 电路 | 减少延迟 | CLA进位预测加速减法 |
| 算法 | 减少计算量 | 6k±1数学优化 |
| 功能 | 扩展位宽 | 时分复用输入16位数据 |

### 开发环境

- **FPGA**: Intel MAX 10 (DE10-Lite 开发板)
- **EDA工具**: Quartus Prime 18.1 Lite
- **仿真工具**: ModelSim Intel FPGA Edition
- **硬件描述语言**: VHDL

---

## 二、优化方案总览

| 优化 | 名称 | 原理 | 性能提升 |
|:----:|------|------|:--------:|
| **1** | 并行除法器 | 2个CLA同时测试÷2和÷3 | 速度 ×2 |
| **2** | CLA快速减法 | 进位预测加速单次减法 | 速度提升 |
| **3** | 6k±1算法 | 只测试2,3和6k±1形式的数 | 除法次数减少 82%~98% |
| **4** | 16位扩展 | 时分复用输入高/低8位 | 范围 0~65535 |

### 性能对比汇总

```
┌─────────────────────────────────────────────────────────────┐
│                     阶段1 vs 阶段2                          │
├─────────────────────────────────────────────────────────────┤
│  指标           │  阶段1        │  阶段2        │  提升     │
├─────────────────────────────────────────────────────────────┤
│  测试范围       │  0-15         │  0-65535      │  4096x    │
│  可检测质数个数  │  6个          │  6542个       │  1090x    │
│  并行度         │  1路          │  3路          │  3x       │
│  测试N=13次数   │  11次除法     │  2次除法      │  减少82%  │
│  测试N=97次数   │  95次除法     │  4次除法      │  减少96%  │
└─────────────────────────────────────────────────────────────┘
```

---

## 三、文件清单

### 3.1 新增源文件 (5个)

| 文件名 | 优化# | 功能说明 |
|--------|:-----:|----------|
| `Prime_Finder_Parallel_Group55.vhd` | 1 | 并行实例化3个除法器，同时测试除以2、3、5 |
| `LongDivision_CLA_Pipeline_Group55.vhd` | 2 | 内置CLA快速减法器的除法器 |
| `Prime_Finder_6k1_Group55.vhd` | 3 | 实现6k±1算法的状态机 |
| `RipSub_8bit_Group55.vhd` | 4 | 8位减法器(级联2个4位RipSub) |
| `Prime_Finder_16bit_Top_Group55.vhd` | 4 | 16位顶层模块，含时分复用输入逻辑 |

### 3.2 新增 Testbench 文件 (4个)

| 文件名 | 优化# | 测试内容 |
|--------|:-----:|----------|
| `Parallel_tb_Group55.vhd` | 1 | 测试 N=7, N=9，验证并行工作 |
| `CLA_Pipeline_tb_Group55.vhd` | 2 | 对比 CLA vs RipSub 速度 |
| `Algorithm_6k1_tb_Group55.vhd` | 3 | 测试 N=13, N=9，验证除法次数减少 |
| `Extend_16bit_tb_Group55.vhd` | 4 | 测试 N=17, N=257，验证16位输入 |

### 3.3 修改的阶段1文件 (2个)

| 文件名 | 修改内容 |
|--------|----------|
| `LongDivision_4bit_Group55.vhd` | 添加 `Done` 和 `Sub_Count` 输出端口 |
| `Prime_Finder_Group55.vhd` | 更新 component 声明以匹配新信号 |

### 3.4 新增性能计数器

所有除法器和优化模块现在都输出 `Sub_Count` 信号，用于显示真实的减法次数：

| 模块 | Sub_Count 位宽 | 说明 |
|------|:--------------:|------|
| `LongDivision_4bit_Group55` | 4位 | 单次除法的减法次数 |
| `LongDivision_CLA_Pipeline_Group55` | 4位 | 单次除法的减法次数 |
| `Prime_Finder_Parallel_Group55` | 8位 | 3个除法器的减法总和 |
| `Prime_Finder_6k1_Group55` | 8位 | 所有除法的减法累计 |

---

## 四、各优化详细说明

### 4.1 优化1: 并行除法器

#### 原理图解

```
阶段1 (串行):                    阶段2 (并行):
                                 
      N                                N
      │                                │
      ▼                     ┌──────────┼──────────┐
 ┌─────────┐                ▼          ▼          ▼
 │ 除法器  │ ← 复用     ┌───────┐ ┌───────┐ ┌───────┐
 └─────────┘            │除法器1│ │除法器2│ │除法器3│
      │                 │ N÷2  │ │ N÷3  │ │ N÷5  │
      ▼                 └───────┘ └───────┘ └───────┘
   时钟1-5                  │         │         │
    N÷2                     ▼         ▼         ▼
      │                   R=?       R=?       R=?
      ▼                     └─────────┴─────────┘
   时钟6-10                          │
    N÷3                    全部R≠0 → 是质数!
      │                 
   总时间: 15周期            总时间: 5周期 (快3倍!)
```

#### 关键信号

| 信号名 | 位宽 | 方向 | 说明 |
|--------|:----:|:----:|------|
| `N` | 4 | IN | 待检测的数 |
| `Done` | 1 | OUT | 检测完成标志 |
| `Is_Prime` | 1 | OUT | 质数结果 (1=是质数) |
| `Sub_Count` | 8 | OUT | **减法总次数 (新增)** |
| `Done2/Done3/Done5` | 1 | 内部 | 各除法器完成标志 |

---

### 4.2 优化2: CLA 快速减法器

#### CLA 减法器原理

```
纹波借位 (阶段1 RipSub):         进位预测 CLA (阶段2):
                               
A[3] B[3]  A[2] B[2]  ...           A[3:0]  B[3:0]
  │   │      │   │                     │      │
  ▼   ▼      ▼   ▼                     └──┬───┘
┌─────┐    ┌─────┐                        ▼
│SUB3 │◄───│SUB2 │◄── ...          ┌──────────────┐
└──┬──┘    └──┬──┘                 │  预测逻辑    │
   │          │                    │ 同时算出     │
延迟: 4T     延迟累积              │ B0,B1,B2,B3  │
                                   └──────────────┘
                                          │
                                   延迟: 2T (快2倍!)
```

#### CLA 优势说明

- **RipSub (纹波借位)**：借位信号需要逐级传递，4位减法需要4级门延迟
- **CLA (进位预测)**：所有借位信号并行计算，4位减法只需2级门延迟
- **结果**：每次减法操作的组合逻辑延迟减半，可支持更高的时钟频率

---

### 4.3 优化3: 6k±1 算法

#### 数学原理

所有大于3的质数都可以写成 **6k±1** 的形式：

```
任何整数都是以下6种形式之一:
  6k     → 能被6整除 (不是质数)
  6k+1   → 可能是质数 ✓
  6k+2   → 能被2整除 (不是质数)
  6k+3   → 能被3整除 (不是质数)
  6k+4   → 能被2整除 (不是质数)
  6k+5   → 等于6(k+1)-1，可能是质数 ✓

结论: 除了2和3，质数只可能是 6k-1 或 6k+1 形式
```

#### 算法流程

```
┌─────────────┐
│   输入 N    │
└──────┬──────┘
       ▼
┌─────────────┐    是
│  N ≤ 3 ?    │────────→ N≥2 则是质数
└──────┬──────┘
       │ 否
       ▼
┌─────────────┐    是
│  N % 2 = 0? │────────→ 不是质数
└──────┬──────┘
       │ 否
       ▼
┌─────────────┐    是
│  N % 3 = 0? │────────→ 不是质数
└──────┬──────┘
       │ 否
       ▼
┌──────────────────────┐
│ d = 5                │
│ while d*d ≤ N:       │
│   if N%d=0 或        │
│      N%(d+2)=0       │
│     → 不是质数       │
│   d = d + 6          │ ← 只测试 6k±1 形式
└──────────────────────┘
       │
       ▼
    是质数!
```

#### 效率对比

| 被测数N | 传统方法 | 6k±1优化 | 减少比例 |
|:-------:|:--------:|:--------:|:--------:|
| 13 | 11次 | 2次 | **82%** |
| 97 | 95次 | 4次 | **96%** |
| 251 | 249次 | 6次 | **98%** |

---

### 4.4 优化4: 16位扩展

#### 时分复用原理

```
问题: 开发板只有10个开关，如何输入16位数据?

解决方案: 分两次输入

┌─────────────────────────────────────────────────────┐
│                  16位时分复用输入                    │
├─────────────────────────────────────────────────────┤
│                                                      │
│  Step 1: 输入高8位                                  │
│  ┌───────────────────────────────┐                  │
│  │ SW[7:0] = 高8位数据           │                  │
│  │ 按 KEY[0] 锁存               │                  │
│  └───────────────────────────────┘                  │
│                                                      │
│  Step 2: 输入低8位                                  │
│  ┌───────────────────────────────┐                  │
│  │ SW[7:0] = 低8位数据           │                  │
│  │ 按 KEY[1] 开始计算            │                  │
│  └───────────────────────────────┘                  │
│                                                      │
│  组合结果: data_full[15:0] = {高8位, 低8位}        │
│                                                      │
└─────────────────────────────────────────────────────┘
```

#### 状态机

```
        ┌────────────┐
        │ WAIT_HIGH  │ ← 初始状态，等待输入高8位
        └─────┬──────┘
              │ KEY0 按下
              ▼
        ┌────────────┐
        │ WAIT_LOW   │ ← 高位已锁存，等待输入低8位
        └─────┬──────┘
              │ KEY1 按下
              ▼
        ┌────────────┐
        │ COMPUTING  │ ← 正在计算质数
        └─────┬──────┘
              │ 计算完成
              ▼
        ┌────────────┐
        │ SHOW_RESULT│ ← 显示结果
        └─────┬──────┘
              │ KEY0 按下
              ▼
         返回 WAIT_HIGH
```

---

## 五、Testbench 仿真指南

### 5.1 运行仿真的方法


#### 方法1: ModelSim 图形界面

1. 打开 Quartus 项目
2. 菜单: `Tools` → `Run Simulation Tool` → `RTL Simulation`
3. 在 ModelSim 中选择对应的 testbench entity 运行

---

### 5.2 Testbench 1: `Parallel_tb_Group55.vhd` - 并行除法器验证

#### 测试目的

验证3个除法器（除以2、3、5）是否真正**并行工作**，而不是串行执行。

#### 测试用例

| 测试# | 输入 N | 期望 Is_Prime | 期望 Done | 验证点 |
|:-----:|:------:|:-------------:|:---------:|--------|
| 1 | 7 | **1** (是质数) | 1 | 7不能被2,3,5整除 |
| 2 | 9 | **0** (非质数) | 1 | 9=3×3，能被3整除 |

#### Quartus 波形数据对照表 - 测试1 (N=7)

时钟周期 20ns，以下为关键时间点的信号值：

| 时间 (ns) | CLK | Load | N | Done | Is_Prime | cycle_count | 说明 |
|:---------:|:---:|:----:|:-:|:----:|:--------:|:-----------:|------|
| 0 | 0 | 0 | 0000 | 0 | 0 | 0 | 初始状态 |
| 40 | ↑ | 1 | 0111 | 0 | 0 | 0 | Load上升沿，N=7 |
| 60 | ↑ | 0 | 0111 | 0 | 0 | 1 | 开始计算 |
| 80 | ↑ | 0 | 0111 | 0 | 0 | 2 | 计算中 |
| 100 | ↑ | 0 | 0111 | 0 | 0 | 3 | 计算中 |
| 120 | ↑ | 0 | 0111 | 0 | 0 | 4 | 计算中 |
| 140 | ↑ | 0 | 0111 | **1** | **1** | 5 | ✓ 完成，是质数 |

#### Quartus 波形数据对照表 - 测试2 (N=9)

| 时间 (ns) | CLK | Load | N | Done | Is_Prime | cycle_count | 说明 |
|:---------:|:---:|:----:|:-:|:----:|:--------:|:-----------:|------|
| 240 | ↑ | 1 | 1001 | 0 | 0 | 0 | Load上升沿，N=9 |
| 260 | ↑ | 0 | 1001 | 0 | 0 | 1 | 开始计算 |
| 280 | ↑ | 0 | 1001 | 0 | 0 | 2 | 计算中 |
| 300 | ↑ | 0 | 1001 | 0 | 0 | 3 | 计算中 |
| 320 | ↑ | 0 | 1001 | 0 | 0 | 4 | 计算中 |
| 340 | ↑ | 0 | 1001 | **1** | **0** | 5 | ✓ 完成，不是质数 |

#### 关键信号值汇总

| 信号 | N=7 结束时 | N=9 结束时 | 对照要点 |
|------|:----------:|:----------:|----------|
| `N` | 0111 (7) | 1001 (9) | 输入值正确 |
| `Done` | 1 | 1 | 两次都完成 |
| `Is_Prime` | **1** | **0** | 7是质数，9不是 |
| `Sub_Count` | 9 | 8 | **减法总次数** |
| `cycle_count` | 5 | 5 | 并行执行周期相同 |

#### 并行验证关键观察点

如果模块内部暴露了 `Done2`, `Done3`, `Done5` 信号，在波形中观察：

| 时间点 | Done2 | Done3 | Done5 | 说明 |
|:------:|:-----:|:-----:|:-----:|------|
| 计算中 | 0 | 0 | 0 | 三个除法器同时工作 |
| 完成时 | **1** | **1** | **1** | **三个信号同时变1 = 并行成功** |

```
并行成功的波形特征:
Done2, Done3, Done5 在同一时刻(或1个周期内)全部变为'1'

串行的波形特征 (错误):
Done2 先变'1'，过几个周期后 Done3 变'1'，再过几个周期 Done5 变'1'
```

---

### 5.3 Testbench 2: `CLA_Pipeline_tb_Group55.vhd` - CLA 减法器验证

#### 测试目的

对比 CLA 减法器与 RipSub 减法器的速度差异。

#### 测试用例

| 测试 | 输入 | 期望输出 | 验证点 |
|:----:|------|----------|--------|
| 1 | 7÷3 | Q=2, R=1 | CLA 比 RipSub 更快完成 |

#### Quartus 波形数据对照表 - Part 1 速度对比 (7÷3)

时钟周期 20ns，观察 CLA 与 RipSub 的完成时间差：

| 时间 (ns) | Load | Dividend | Divisor | Done_CLA | Done_Rip | Q_CLA | Q_Rip | 说明 |
|:---------:|:----:|:--------:|:-------:|:--------:|:--------:|:-----:|:-----:|------|
| 40 | 1 | 0111 | 0011 | 0 | 0 | X | X | Load脉冲，7÷3 |
| 60 | 0 | 0111 | 0011 | 0 | 0 | X | X | 计算中 |
| 80 | 0 | 0111 | 0011 | 0 | 0 | X | X | 计算中 |
| 100 | 0 | 0111 | 0011 | **1** | 0 | **0010** | X | ✓ CLA完成! |
| 120 | 0 | 0111 | 0011 | 1 | 0 | 0010 | X | RipSub还在算 |
| 140 | 0 | 0111 | 0011 | 1 | **1** | 0010 | **0010** | ✓ RipSub完成 |

#### Part 1 关键对比数据

| 指标 | CLA 版本 | RipSub 版本 | 结论 |
|------|:--------:|:-----------:|------|
| **Done 变1时间** | 100 ns | 140 ns | CLA 快 40ns |
| **cycle 计数** | **3** | **5** | CLA 少 2 周期 |
| **Sub_Count** | **2** | **2** | 减法次数相同 |
| **Q (商)** | 0010 (2) | 0010 (2) | 结果相同 ✓ |
| **R (余数)** | 0001 (1) | 0001 (1) | 结果相同 ✓ |

**验证成功标志**: `Done_CLA` 在 `Done_Rip` 之前变为 '1'，且 `cycle_cla < cycle_rip`

> **注意**: Sub_Count 相同说明CLA和RipSub执行相同数量的减法，但CLA每次减法更快

---

### 5.4 Testbench 3: `Algorithm_6k1_tb_Group55.vhd` - 6k±1 算法验证

#### 测试目的

验证使用6k±1算法后，**除法次数大幅减少**。

#### 测试用例

| 测试# | 输入 N | 期望 Is_Prime | 期望 Div_Count | 传统方法次数 |
|:-----:|:------:|:-------------:|:--------------:|:------------:|
| 1 | 13 | **1** | ≤2 | 11次 |
| 2 | 9 | **0** | 2 | 7次 |

#### 核心对比解释

```
测试 N=13 是否为质数:

传统方法:
  测试除数: 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
  共 11 次除法

6k±1 优化方法:
  Step 1: 13 % 2 = 1 ≠ 0   ← 第1次除法
  Step 2: 13 % 3 = 1 ≠ 0   ← 第2次除法
  Step 3: 下一个测试5，但 5² = 25 > 13，停止!
  
  共 2 次除法，效率提升 11/2 = 5.5 倍!
```

#### Quartus 波形数据对照表 - 测试1 (N=13, 质数)

时钟周期 20ns，重点观察 `Div_Count` 信号：

| 时间 (ns) | Load | N | Div_Count | Done | Is_Prime | 说明 |
|:---------:|:----:|:-:|:---------:|:----:|:--------:|------|
| 40 | 1 | 1101 | 0000 | 0 | 0 | Load脉冲，N=13 |
| 60 | 0 | 1101 | 0000 | 0 | 0 | 检查特殊值 |
| 80 | 0 | 1101 | **0001** | 0 | 0 | 第1次除法: 13÷2 |
| 100 | 0 | 1101 | 0001 | 0 | 0 | 等待除法完成 |
| 120 | 0 | 1101 | **0010** | 0 | 0 | 第2次除法: 13÷3 |
| 140 | 0 | 1101 | 0010 | 0 | 0 | 等待除法完成 |
| 160 | 0 | 1101 | 0010 | **1** | **1** | ✓ 完成! 5²>13 停止 |

#### Quartus 波形数据对照表 - 测试2 (N=9, 合数)

| 时间 (ns) | Load | N | Div_Count | Done | Is_Prime | 说明 |
|:---------:|:----:|:-:|:---------:|:----:|:--------:|------|
| 260 | 1 | 1001 | 0000 | 0 | 0 | Load脉冲，N=9 |
| 280 | 0 | 1001 | 0000 | 0 | 0 | 检查特殊值 |
| 300 | 0 | 1001 | **0001** | 0 | 0 | 第1次除法: 9÷2=4余1 |
| 320 | 0 | 1001 | 0001 | 0 | 0 | 余数≠0，继续 |
| 340 | 0 | 1001 | **0010** | 0 | 0 | 第2次除法: 9÷3=3余0 |
| 360 | 0 | 1001 | 0010 | **1** | **0** | ✓ 余数=0，不是质数! |

#### 关键信号值汇总

| 信号 | N=13 结束时 | N=9 结束时 | 对照要点 |
|------|:----------:|:----------:|----------|
| `N` | 1101 (13) | 1001 (9) | 输入正确 |
| `Div_Count` | **0010 (2)** | **0010 (2)** | **关键! 只有2次除法** |
| `Sub_Count` | **10** | **7** | **减法总次数** |
| `Done` | 1 | 1 | 两次都完成 |
| `Is_Prime` | **1** | **0** | 13是质数，9不是 |

#### 效率对比验证

| 被测数 | 6k±1 Div_Count | 传统方法次数 | 效率提升 |
|:------:|:--------------:|:------------:|:--------:|
| N=13 | **2** | 11 | **5.5倍** |
| N=9 | **2** | 7 | **3.5倍** |

**验证成功标志**: `Div_Count` 最终值远小于 `N-2`

---

### 5.5 Testbench 4: `Extend_16bit_tb_Group55.vhd` - 16位扩展验证

#### 测试目的

验证**时分复用输入**能正确处理16位数据。

#### 测试用例

| 测试# | 输入 N | 高8位 (hex) | 低8位 (hex) | 期望 LEDR(9) |
|:-----:|:------:|:-----------:|:-----------:|:------------:|
| 1 | 17 | 0x00 | 0x11 | **1** (是质数) |
| 2 | 257 | 0x01 | 0x01 | **1** (是质数) |

#### Quartus 波形数据对照表 - 测试1 (N=17)

时钟周期 20ns，观察时分复用输入过程：

| 时间 (ns) | SW[7:0] | KEY[1:0] | state | data_high | data_full | LEDR(9) | 说明 |
|:---------:|:-------:|:--------:|:-----:|:---------:|:---------:|:-------:|------|
| 100 | 00000000 | 11 | WAIT_HIGH | XX | XXXX | 0 | 初始状态 |
| 140 | 00000000 | **10** | WAIT_HIGH | XX | XXXX | 0 | 按下KEY0 |
| 180 | 00000000 | 11 | **WAIT_LOW** | **00** | XXXX | 0 | 高位已锁存 |
| 220 | **00010001** | 11 | WAIT_LOW | 00 | XXXX | 0 | 设置低位=0x11 |
| 260 | 00010001 | **01** | WAIT_LOW | 00 | XXXX | 0 | 按下KEY1 |
| 300 | 00010001 | 11 | **COMPUTING** | 00 | **0011** | 0 | 组合完成，开始计算 |
| ... | ... | 11 | COMPUTING | 00 | 0011 | 0 | 计算质数中 |
| 4000+ | 00010001 | 11 | **SHOW** | 00 | 0011 | **1** | ✓ 完成! 17是质数 |

#### Quartus 波形数据对照表 - 测试2 (N=257)

| 时间 (ns) | SW[7:0] | KEY[1:0] | state | data_high | data_full | LEDR(9) | 说明 |
|:---------:|:-------:|:--------:|:-----:|:---------:|:---------:|:-------:|------|
| 4200 | 00000001 | 11 | WAIT_HIGH | XX | XXXX | X | 设置高位=0x01 |
| 4240 | 00000001 | **10** | WAIT_HIGH | XX | XXXX | X | 按下KEY0 |
| 4280 | 00000001 | 11 | **WAIT_LOW** | **01** | XXXX | X | 高位已锁存 |
| 4320 | **00000001** | 11 | WAIT_LOW | 01 | XXXX | X | 设置低位=0x01 |
| 4360 | 00000001 | **01** | WAIT_LOW | 01 | XXXX | X | 按下KEY1 |
| 4400 | 00000001 | 11 | **COMPUTING** | 01 | **0101** | 0 | 组合=257，开始计算 |
| ... | ... | 11 | COMPUTING | 01 | 0101 | 0 | 计算质数中 |
| 8000+ | 00000001 | 11 | **SHOW** | 01 | 0101 | **1** | ✓ 完成! 257是质数 |

#### 状态机转换对照表

| 阶段 | state 值 | LEDR[8:5] | 触发条件 |
|------|:--------:|:---------:|----------|
| 1. 等待高位 | WAIT_HIGH | 1000 | 初始/KEY0重置 |
| 2. 等待低位 | WAIT_LOW | 0100 | KEY0 按下后 |
| 3. 计算中 | COMPUTING | 0010 | KEY1 按下后 |
| 4. 显示结果 | SHOW_RESULT | 0001 | 计算完成后 |

#### 关键信号值汇总

| 信号 | N=17 结束时 | N=257 结束时 | 对照要点 |
|------|:----------:|:----------:|----------|
| `SW` | 00010001 | 00000001 | 最后输入的低位 |
| `data_high` | 00 (0x00) | 01 (0x01) | 锁存的高8位 |
| `data_full` | 0000000000010001 (17) | 0000000100000001 (257) | 16位组合值 |
| `state` | SHOW_RESULT | SHOW_RESULT | 显示状态 |
| `LEDR(9)` | **1** | **1** | **17和257都是质数** |
| `LEDR(8:5)` | 0001 | 0001 | SHOW状态指示 |

#### 验证成功标志

1. `state` 按顺序经过: WAIT_HIGH → WAIT_LOW → COMPUTING → SHOW_RESULT
2. `data_full` 正确组合高低位: `{data_high, SW[7:0]}`
3. `LEDR(9)` 显示正确的质数判断结果

---

## 六、开发板验证

### 6.1 烧录准备

1. 在 Quartus 中设置顶层模块为 `Prime_Finder_16bit_Top_Group55`
2. 编译项目: `Processing` → `Start Compilation`
3. 烧录: `Tools` → `Programmer` → `Start`

### 6.2 引脚映射

| 外设 | 引脚 | 功能 |
|------|------|------|
| SW[7:0] | PIN_C10~PIN_A14 | 8位数据输入 |
| SW[9] | PIN_B14 | 保留/模式选择 |
| KEY[0] | PIN_B8 | 锁存高8位 / 重新开始 |
| KEY[1] | PIN_A7 | 锁存低8位 + 开始计算 |
| LEDR[9] | PIN_B11 | **质数结果** (亮=是质数) |
| LEDR[8] | PIN_A11 | WAIT_HIGH 状态 |
| LEDR[7] | PIN_D14 | WAIT_LOW 状态 |
| LEDR[6] | PIN_E14 | COMPUTING 状态 |
| LEDR[5] | PIN_C13 | SHOW_RESULT 状态 |
| HEX0~HEX5 | - | 数值/状态显示 |

### 6.3 验证示例

#### 示例1: 测试 N=17 (小质数)

| 步骤 | 操作 | 开发板显示 |
|:----:|------|------------|
| 1 | SW[7:0] = `00000000` | HEX 显示 "HI" |
| 2 | 按下 KEY0 | HEX 显示 "LO 00" |
| 3 | SW[7:0] = `00010001` (0x11=17) | - |
| 4 | 按下 KEY1 | HEX 显示 "----" |
| 5 | 等待计算 | HEX 显示数值, **LED9 亮** |
| 6 | 按 KEY0 重新开始 | 返回 "HI" |

#### 示例2: 测试 N=256 (合数 2⁸)

| 步骤 | 操作 | 预期结果 |
|:----:|------|----------|
| 1 | SW = `00000001` (高位) | - |
| 2 | 按 KEY0 | 锁存 0x01 |
| 3 | SW = `00000000` (低位) | - |
| 4 | 按 KEY1 | 开始计算 |
| 5 | 等待 | **LED9 灭** (256 不是质数) |

#### 示例3: 测试 N=257 (大质数)

| 步骤 | 操作 | 预期结果 |
|:----:|------|----------|
| 1 | SW = `00000001` | - |
| 2 | 按 KEY0 | 锁存 0x01 |
| 3 | SW = `00000001` | - |
| 4 | 按 KEY1 | 开始计算 |
| 5 | 等待 | **LED9 亮** (257 是质数) |

#### 更多测试数值

| 数值 | 高8位 (SW) | 低8位 (SW) | 是否质数 |
|:----:|:----------:|:----------:|:--------:|
| 2 | 00000000 | 00000010 | 是 |
| 100 | 00000000 | 01100100 | 否 |
| 127 | 00000000 | 01111111 | 是 |
| 1000 | 00000011 | 11101000 | 否 |
| 1009 | 00000011 | 11110001 | 是 |
| 65521 | 11111111 | 11110001 | 是 (最大16位质数) |

---

## 七、快速开始

### 7.1 仿真验证 (5分钟)

```bash
# 1. 打开 ModelSim
# 2. 切换到项目目录
cd {D:/intelFPGA_lite/18.1/project/Prime_Finder/simulation/modelsim}

# 3. 运行任一 testbench
vsim work.parallel_tb_group55
run -all

# 4. 查看波形
add wave -position insertpoint sim:/parallel_tb_group55/*
restart -force
run -all
```

### 7.2 开发板验证 (10分钟)

1. Quartus: 设置顶层为 `Prime_Finder_16bit_Top_Group55`
2. 编译并烧录
3. 按上述示例操作开关和按键

### 7.3 视频录制建议

| 优化 | 展示内容 | 时长 |
|:----:|----------|:----:|
| 1 | ModelSim 波形: Done2/Done3/Done5 同时变化 + Sub_Count | 45秒 |
| 2 | ModelSim 波形: CLA vs RipSub 完成时间对比 | 45秒 |
| 3 | ModelSim 波形: Div_Count + Sub_Count 最终值对比 | 60秒 |
| 4 | 开发板操作: 输入 17 和 257 验证 | 90秒 |

---

## 文件依赖关系图

```
阶段1基础模块 (必须保留):
├── And_2bit_Group55.vhd
├── Full_adder_Group55.vhd
├── RipSub_4bit_Group55.vhd ────────────┐
├── Multiplier_4bit_Group55.vhd         │
├── LongDivision_4bit_Group55.vhd ◄─────┤ (被优化1,2,3复用)
├── Prime_Finder_Group55.vhd            │
└── Prime_Finder_Top_Group55.vhd        │
                                        │
阶段2优化模块:                          │
├── Prime_Finder_Parallel_Group55.vhd ◄─┘ (优化1: 实例化3个除法器)
├── LongDivision_CLA_Pipeline_Group55.vhd  (优化2: 独立CLA实现)
├── Prime_Finder_6k1_Group55.vhd ◄─────────(优化3: 复用除法器)
├── RipSub_8bit_Group55.vhd ◄──┐
└── Prime_Finder_16bit_Top_Group55.vhd     (优化4: 16位顶层)

Testbench:
├── Parallel_tb_Group55.vhd        → 验证优化1
├── CLA_Pipeline_tb_Group55.vhd    → 验证优化2
├── Algorithm_6k1_tb_Group55.vhd   → 验证优化3
└── Extend_16bit_tb_Group55.vhd    → 验证优化4
```

---

## 作者信息

- **项目组**: Group 55
- **课程**: 数字电路与逻辑设计
- **开发时间**: 2025年12月

---

*本文档可作为项目 README 和演示参考*
